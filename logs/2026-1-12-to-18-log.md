## Tiến độ (5-11/1/2026)
1. Grammar: Đã xây dựng thành công Grammar cho API addAnnot (AcroJS).
- Tham số của API này có tính phụ thuộc cao (liên kết Page và Annotation), khả năng cao gây ra lỗi Use-After-Free hoặc Null Dereference nếu mutation tốt.
- Sử dụng Nautilus để sinh thành công các đoạn mã JS (file masterAcroJS.py) từ grammar này.
2. Script: Hoàn thiện script builder.py
- Tự động nhúng đoạn JS sinh ra vào cấu trúc file PDF.
- Đã verify trên Adobe Reader và Foxit Reader, file mở được, mã JS thực thi (chưa crash), chứng minh format file hợp lệ.
## Kế hoạch và đề xuất (5-11/1/2026)
1. Thay vì mở rộng Grammar ngay, em đề xuất ưu tiên xây dựng pipeline hoàn chỉnh (End-to-End) trước. Mục tiêu là để hệ thống: Sinh Input $\to$ Chạy trên Windows $\to$ Instrumentation/Feedback $\to$ Crash hoạt động trơn tru. Điều này giúp kiểm chứng tính khả thi của phương pháp (Proof of Concept) sớm.
    - Giải pháp kỹ thuật:
        - Việc tích hợp Nautilus (Rust/Linux) vào WinAFL (C/Windows) gặp rào cản lớn về kiến trúc và giao tiếp (IPC). Cụ thể, WinAFL chỉ hỗ trợ Custom Mutator dạng DLL đơn giản, đầu vào của custom mutator là nội dung file chứ không nhận feedback (code coverage, path mới,...) do đó nó không thể quyết định xem là nên tạo input mới hay mutate input cũ như Nautilus được.
        - Em đề xuất chuyển sang sử dụng LibAFL Framework. Do LibAFL hỗ trợ Native Windows, có sẵn module Nautilus (Grammar) và hỗ trợ Instrumentation hiện đại (Frida/TinyInst) thay thế DynamoRIO cũ. Đây là hướng đi chuẩn mực hiện nay cho các custom fuzzer phức tạp.
## Task (12-18/1/2026)
1. Cài đặt libAFL và chạy examples của libAFL (tininst_simple, baby_fuzzer_windows, baby_fuzzer_nautilus)
    - Mục tiêu: Chứng minh là có thể fuzzing 1 file binary trên Windows.
## Notes (12-18/1/2026)
### LibAFL
- `libafl` là một bộ sưu tập các thành phần có thể tái sử dụng được của nhiều fuzzers, do đó có thể hoàn toàn tùy chỉnh các thành phần của fuzzer sao cho phù hợp.
- sử dụng ngôn ngữ lập trình Rust
- ưu điểm: tối ưu tại compile time để giảm overhead, tận dụng hết các core, có thể thay thế các thành phần, chạy được nhiều nền tảng (windows, linux, macos, embedded devices,...) và hỗ trợ binary-only mode.
- 3 thành phần cơ bản:
    - `libafl` (core): chứa main library và các fuzzing components
    - `libafl targets`: thư viện sử dụng cho việc instrument target, trong thư viện này sẽ implement các hàm mà sẽ được sử dụng để "sống" bên trong target nhằm theo dõi trạng thái,...
    - `libafl cc`: thư viện sử dụng để viết tạo ra compiler tùy chỉnh, tức là thư viện sử dụng để tạo ra compiler tương tự `afl-cc`, và nhiệm vụ của phần này là quyết định xem chèn các hàm theo dõi của `libafl targets` vào đâu.
- các thành phần phụ
    - `instrumentation backend` : cung cấp các API để kết nối với các công cụ chạy nền khác như qemu hoặc frida để fuzzer chạy được trên các binary closed-source.
    - `fuzzer frontends`: tạo ra các API cao cấp giúp người dùng tạo ra một fuzzer hoàn chỉnh chỉ với vài dòng code cho vài trường hợp phổ biến.
- Thiết kế:
    - state: lưu `non volatile data`, tức lưu những dữ liệu cần được dữ liệu và có thể khôi phục lại được
    - fuzzer: scheduler, feedbacks, objectives
    - event managers: giao tiếp giữa các thành phần trong fuzzzers, cho phép fuzzer trên nhiều lõi, nhiều máy tính
    - instrument backends: 