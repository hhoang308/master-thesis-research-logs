## Tiến độ (5-11/1/2026)
1. Grammar: Đã xây dựng thành công Grammar cho API addAnnot (AcroJS).
- Tham số của API này có tính phụ thuộc cao (liên kết Page và Annotation), khả năng cao gây ra lỗi Use-After-Free hoặc Null Dereference nếu mutation tốt.
- Sử dụng Nautilus để sinh thành công các đoạn mã JS (file masterAcroJS.py) từ grammar này.
2. Script: Hoàn thiện script builder.py
- Tự động nhúng đoạn JS sinh ra vào cấu trúc file PDF.
- Đã verify trên Adobe Reader và Foxit Reader, file mở được, mã JS thực thi (chưa crash), chứng minh format file hợp lệ.
## Kế hoạch và đề xuất (5-11/1/2026)
1. Thay vì mở rộng Grammar ngay, em đề xuất ưu tiên xây dựng pipeline hoàn chỉnh (End-to-End) trước. Mục tiêu là để hệ thống: Sinh Input $\to$ Chạy trên Windows $\to$ Instrumentation/Feedback $\to$ Crash hoạt động trơn tru. Điều này giúp kiểm chứng tính khả thi của phương pháp (Proof of Concept) sớm.
    - Giải pháp kỹ thuật:
        - Việc tích hợp Nautilus (Rust/Linux) vào WinAFL (C/Windows) gặp rào cản lớn về kiến trúc và giao tiếp (IPC). Cụ thể, WinAFL chỉ hỗ trợ Custom Mutator dạng DLL đơn giản, đầu vào của custom mutator là nội dung file chứ không nhận feedback (code coverage, path mới,...) do đó nó không thể quyết định xem là nên tạo input mới hay mutate input cũ như Nautilus được.
        - Em đề xuất chuyển sang sử dụng LibAFL Framework. Do LibAFL hỗ trợ Native Windows, có sẵn module Nautilus (Grammar) và hỗ trợ Instrumentation hiện đại (Frida/TinyInst) thay thế DynamoRIO cũ. Đây là hướng đi chuẩn mực hiện nay cho các custom fuzzer phức tạp.
## Task (12-18/1/2026)
1. Cài đặt libAFL và chạy examples của libAFL (tininst_simple, baby_fuzzer_windows, baby_fuzzer_nautilus)
    - Mục tiêu: Chứng minh là có thể fuzzing 1 file binary trên Windows.
## Notes (12-18/1/2026)