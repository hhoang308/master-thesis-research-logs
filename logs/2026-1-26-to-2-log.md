## Target
1. Xây dựng Pipeline cơ bản, bao gồm: Grammar -> Seed -> Execute -> Feedback -> Mutator/Generate Seed -> ..., cho đối tượng là binary-only
2. Rust
    - Syntax
    - Ownership and Borrowing
    - Data Structure and Error Handling
    - Trait and Generics
## Log
### The LibAFL Fuzzing Library
#### crates
- LibAFL is composed of different crates which is an individual library.
- `crates` list:
    - `libafl`: main crate, contains all the components needed to build a fuzzer.
        - choose features flags, some are already set by default, to configure the library:
            - `std`: enables the parts of the code that use the Rust standard library, only disables if you intent to use LibAFL in embedded environments.
            - `llmp_bind_public`: bind to a public TCP port, allows other fuzzers node can communicate with this instance.
            - `introspection`: adds performance statistics to LibAFL
    - `libafl_bolts`: contains useful low-level rust features.
        - `core_affinity`: bind curent process to cores.
    - `libafl_sugar`: `LibAFL`'s API, easy-to-use but not as flexible as stitching together from each individual component.
    - `libafl_derive`: exposes macro that can be used to define Metadata structs.
    - `libafl_targets`: instrument targets.
        - supported flags:
            - `pcguard_edges`: track the executed edges in a map.
            - `pcguard_hitcounts`: track the executed edges with the hitcounts (like AFL) in a map.
    - `libafl_cc`: provides utils to wrap compilers and create source-level fuzzers, currently, only Clang compiler is supported.
    - `libafl_frida`: bridges LibAFL with Frida as instrumentation backend, then instrument targets on Linux/macOS/Windows/Android for coverage collection.
    - `libafl_qemu`: bridges LibAFL with QEMU user-mode to fuzz ELF cross-platform binaries.
    - `libafl_nyx`: add capabilities of KVM-based snapshot fuzzer to LibAFL.
    - `libafl_concolic`: add symbolic execution engine to reach greater depth than normal fuzzing.