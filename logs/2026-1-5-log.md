## Task

#### AcroJS
- Mục tiêu:
    - Xác định những API quan trọng, có khả năng bị tấn công.
##### 1. Tiêu chí đánh giá API
1. Liên quan đến việc quản lý vòng đời của object, ví dụ như tạo, xóa, sửa,...vì có thể gặp lỗi use-after-free liên quan đến việc một đối tượng vẫn duy trì tham chiếu đến đối tượng đã bị thay đổi.
    - addAnnot / deleteAnnot
    - addField / removeField
    - deletePages / insertPages
    - destroy()
2. Xử lý dữ liệu phức tạp do C++ phải xử lý phần này
    - util.scand
    - util.printf
    - XMLData
    - ReadStream / WriteStream.
3. Các API legacy
    - media, sound, screen
    - context3D
    - spell
    - collab
4. Tương tác hệ thống
    - app.launchURL
    - doc.importDataObject
5. Đã từng bị khai thác trong quá khứ
    - collab
    - Annot, ScreenAnnot, RichMedia
    - xfa.resolveNode, xfa.host
#### Grammar
- Mục tiêu:
    - Xây dựng văn phạm để tạo các file pdf chứa những API quan trọng cần tấn công.
##### Các Grammar đã tạo được:
1. addAnnot
`/home/hoangnh8/master-thesis-daily-logs/logs/addAnnotGrammar.py`

#### Cơ chế thu thập feedback rồi thực hiện biến đổi của Nautilus

#### Cơ chế thu thập feedback rồi thực hiện biến đổi của AFL++

#### Cơ chế thu thập feedback rồi thực hiện biến đổi của WinAFL

## Takeaway
- AcroJS cho phép thao tác với AOM (Acrobat Object Model), ví dụ như: `app`, `doc` (tệp PDF hiện tại), `util`, `event`, `security`.
- Phần code JavaScript sẽ nằm trong giá trị của khóa `/JS`, thuộc một object có kiểu là `/Action` và `/OpenAction`.
- `safe path` is a path on local hard drive that passed to JavaScript methods, a path can't point to system critical folder, for example, root directory.
- `privileged context` is a context in which you have the right to do something that is normally restricted. For example, trusting a document certifier's certificate for executing JavaScript creates a `privileged context`.
- some JavaScript methods have security restrictions, these methods can be executed only in a `privileged context`.
- Giải thích file PDF:
    ```
    %PDF-1.3
    %����
    1 0 obj
    << /OpenAction << /JS (\napp.alert\("Hello! Code JavaScript da chay thanh cong!"\);\nvar a = 10;\nvar b = 20;\nconsole.println\("Ket qua: " + \(a+b\)\);\n) /S /JavaScript >> /Pages 2 0 R /Type /Catalog >>
    endobj
    2 0 obj
    << /Count 1 /Kids [ 3 0 R ] /Type /Pages >>
    endobj
    3 0 obj
    << /Contents 4 0 R /MediaBox [ 0 0 612 792 ] /Parent 2 0 R /Resources << >> /Type /Page >>
    endobj
    4 0 obj
    << /Length 0 /Filter /FlateDecode >>
    stream

    endstream
    endobj
    xref
    0 5
    0000000000 65535 f 
    0000000015 00000 n 
    0000000235 00000 n 
    0000000294 00000 n 
    0000000400 00000 n 
    trailer << /Root 1 0 R /Size 5 /ID [<db52d5076dc5b9e9139dbf75a1436839><db52d5076dc5b9e9139dbf75a1436839>] >>
    startxref
    470
    %%EOF
    ```
    - `407` (0x1d6) là byte offset của xref tính từ đầu file ![407](image-3.png)
    - `<<` và `>>` (hay còn gọi là dictionary) là ký hiệu bắt đầu và kết thúc của metadata (tức phần mô tả của object), trong này sẽ chứa các giá trị kiểu key-value. Key bắt buộc phải là một name object và bắt đầu bằng dấu `/`, ví dụ `/Type`, `/Pages`. Value có thể là số, chuỗi, mảng hoặc tham chiếu gián tiếp hoặc một dictionary khác lồng vào trong.
    - `stream` và `endstream` là ký hiệu bắt đầu và kết thúc nội dung (payload) của object.
    - `xref` để biểu thị bắt đầu bằng `cross-reference table`, trong đó `0 5` thông báo có 5 dòng liên tiếp, mỗi dòng mô tả vị trí của các object, bắt đầu từ object 0. Dòng đầu tiên là dòng đặc biệt, đánh dấu danh sách các object đã bị xóa, `65535` là số thế hệ max, `f` nghĩa là free. Các dòng tiếp theo thông báo vị trí của các object còn lại, ví dụ, `0000000015 00000 n` tức object số 1 đang nằm tại byte thứ 15 (`0xf`) của file và vẫn đang hoạt động (`n`), `generation number` là `00000`. PDF hỗ trợ `increment number`, khi xóa hoặc sửa một object, PDF sẽ đánh dấu object cũ là đã xóa và tạo object mới, nếu sau này có sử dụng lại ID của object cũ thì sẽ tăng `generation number` lên. ![15](image-4.png)


## Questions
1. Đọc tài liệu AcroJS nhiều quá nên dễ nản, do đó muốn triển khai pipeline trước, tức khiến cho hệ thống WinAFL + Nautilus + Adobe Reader hoạt động, rồi sau đó bổ sung thêm các API, các văn phạm và cơ chế lập lịch sau.
2. Trong Nautilus cũng có chế độ mutate, cho phép giữ nguyên phần thân cây (tức nơi chứa luật nào đó muôn giữ) và thay đổi giá trị của các nhánh lá khác (tức các tham số), thay vì chỉ tạo mới một cách ngẫu nhiên. Có thể áp dụng cái này vào trước khi sử dụng machine learning.
    - AFL++ sử dụng cơ chế lập lịch dựa trên năng lượng (dựa trên toán học thống kê). Nguyên lý hoạt động là AFL++ gán cho mỗi file đầu vào một mức năng lượng, năng lượng cao thì được mutate nhiều lần và cho phép chạy lâu và ngược lại. Tiêu chí đánh giá mức năng lượng dựa trên: độ hiếm đường đi (càng hiếm năng lượng càng tăng), thời gian thực thi (càng nhanh năng lượng càng tăng), độ bao phủ (bao phủ nhiều năng lượng tăng).
    - AFLSmart sử dụng cơ chế lập lịch giống như AFL++ nhưng thêm một tham số là tính hợp lệ. Nếu một input sau khi mutate mà vẫn giữ được cấu trúc đúng thì mức năng lượng của nó sẽ tăng và ngược lại.
3. Có cần bắt buộc phải sử dụng WinAFL kèm với Nautilus không?
- Có nếu như mục tiêu là AcroJS API, vì mặc dù dù Nautilus có hỗ trợ QEMU để fuzzing các target không có source code rồi nhưng QEMU trong Nautilus là sử dụng cho Linux, và các bản Adobe Reader cho Linux ít được cập nhất hơn so với Windows. Do đó nếu muốn fuzzing Adobe Reader trên Windows thì phải sử dụng WinAFL.

4. Mục tiêu cuối cùng là cho phép fuzzing trên Windows, cụ thể là tập trung vào các AcroJS API của Adobe Reader. Tuy nhiên để tạo được các input cho Adobe Reader cần Nautilus, nhưng để fuzzing cho Windows thì lại cần WinAFL, và hai cái này thì không tách thành 2 phần riêng biệt để bổ trợ nhau. Hiểu đơn giản thì task của tôi là phát triển một grammar-based input generation with feedback directed fuzzing cho hệ điều hành Windows à?
    - Nếu vậy thì nên gộp Nautilus vào WinAFL hay ngược lại?
    - Gemini gợi ý sử dụng LibAFL framework để tự tạo một fuzzer riêng biệt cho trường hợp này, vì nó hỗ trợ Windows native, hỗ trợ module Nautilus và DynamoRIO để chạy trên Windows.
        - Tập trung vào các examples fuzzer của libafl: bao gồm phần grammar trong fuzzer/baby_fuzzer_nautilus, phần windows trong fuzzer/baby_fuzzer_windows, phần thu thập feedback trong fuzzers/frida_libpng hoặc fuzzers/tinyinst_simple.
        - Tham khảo https://aflplus.plus/libafl-book/.

5. LibAFL
- `libafl` là một bộ sưu tập các thành phần có thể tái sử dụng được của nhiều fuzzers, do đó có thể hoàn toàn tùy chỉnh các thành phần của fuzzer sao cho phù hợp.
- sử dụng ngôn ngữ lập trình Rust
- ưu điểm: tối ưu tại compile time để giảm overhead, tận dụng hết các core, có thể thay thế các thành phần, chạy được nhiều nền tảng (windows, linux, macos, embedded devices,...) và hỗ trợ binary-only mode.
- 3 thành phần cơ bản:
    - `libafl` (core): chứa main library và các fuzzing components
    - `libafl targets`: thư viện sử dụng cho việc instrument target, trong thư viện này sẽ implement các hàm mà sẽ được sử dụng để "sống" bên trong target nhằm theo dõi trạng thái,...
    - `libafl cc`: thư viện sử dụng để viết tạo ra compiler tùy chỉnh, tức là thư viện sử dụng để tạo ra compiler tương tự `afl-cc`, và nhiệm vụ của phần này là quyết định xem chèn các hàm theo dõi của `libafl targets` vào đâu.
- các thành phần phụ
    - `instrumentation backend` : cung cấp các API để kết nối với các công cụ chạy nền khác như qemu hoặc frida để fuzzer chạy được trên các binary closed-source.
    - `fuzzer frontends`: tạo ra các API cao cấp giúp người dùng tạo ra một fuzzer hoàn chỉnh chỉ với vài dòng code cho vài trường hợp phổ biến.
- Thiết kế